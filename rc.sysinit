#!/bin/sh
#
# /etc/rc.sysinit
#

. /etc/rc.conf
. /etc/rc.d/functions

echo " "
printhl "Arch Linux v0.7.2 $C_OTHER(${C_H2}Gimmick$C_OTHER)\n"
printhl "${C_H2}http://www.archlinux.org"
printhl "Copyright 2002-2006 Judd Vinet"
printhl "Distributed under the GNU General Public License (GPL)"
printsep

# start up our mini logger until syslog takes over
/sbin/minilogd

# anything more serious than KERN_WARNING goes to the console
/bin/dmesg -n 3

# mount /proc and /sys
mount -n -t proc none /proc
[ "`grep sysfs /proc/filesystems`" ] && mount -n -t sysfs none /sys
	
# mount usbfs  
/sbin/modprobe usbcore >/dev/null 2>&1   
[ "`grep usbfs /proc/filesystems`" ] && mount -n -t usbfs none /proc/bus/usb

if [ -x /etc/start_udev -a -d /sys/block ]; then
	# We have a start_udev script and /sys appears to be mounted, use UDev
	status "Starting UDev Daemon" /etc/start_udev init
else
	# Static /dev, our last resort
	status "Using static /dev filesystem" /bin/true
fi

# Load modules from the MODULES array defined in rc.conf
if ! [ "$load_modules" = "off" ]; then 
	if [ -f /proc/modules ]; then
		stat_busy "Loading Modules"
		for mod in "${MODULES[@]}"; do
			if [ "$mod" = "${mod#!}" ]; then
				/sbin/modprobe $mod
			fi
		done
		stat_done
	fi
fi

# run udev uevents
if [ "`pidof -o %PPID /sbin/udevd`" ]; then
	status "Loading UDev uevents" /etc/start_udev uevents
fi

# If using an encrypted root fs, we should find the root dev in the initrd
if [ -e /initrd/dev/mapper/root ]; then
	mkdir /dev/mapper 2>/dev/null
	cp -a /initrd/dev/mapper/root /dev/mapper/root
fi

# If necessary, find md devices and manually assemble RAID arrays
if [ -f /etc/mdadm.conf -a "`grep ^ARRAY /etc/mdadm.conf 2>/dev/null`" ]; then
	# udev won't create these md nodes, so we do it ourselves
	for dev in `grep ^ARRAY /etc/mdadm.conf | awk '{print $2}'`; do
		path=`echo $dev | sed 's|/[^/]*$||'`
		node=`echo $dev | sed "s|^$path/||"`
		minor=`echo $node | sed 's|^[^0-9]*||'`
		[ ! -f $path/$node ] && /bin/mknod $path/$node b 9 $minor
	done
	status "Activating RAID arrays" /sbin/mdadm --assemble --scan
fi

# Unmount and free up the old initrd if it exists
if [ -f /initrd/linuxrc ]; then
	stat_busy "Freeing memory from Initial Ramdisk"
	umount /initrd 2>/dev/null
	/sbin/blockdev --flushbufs /dev/rd/0 2>/dev/null
	stat_done
fi

# Set up non-root encrypted partition mappings
if [ -f /etc/crypttab ]; then
	CS=/sbin/cryptsetup.static
	while read line; do
		[ "$line" = "" ] && continue
		[ "`echo $line | grep ^#`" ] && continue
		# remove redundant whitespace and split up tokens
		line=`echo $line | awk '{print $0}'`
		cname=`echo $line | cut -d' ' -f1`
		csrc=`echo $line | cut -d' ' -f2`
		cpass=`echo $line | cut -d' ' -f3`
		copts=`echo $line | cut -d' ' -f4-`
		[ "$cpass" = "" ] && continue

		action=create
		$CS isLuks $csrc 2>/dev/null && action=luksOpen

		if [ "`echo $cpass | grep \\\"`" ]; then
			# Trim off the quotes around the password string
			cpass2=`echo $cpass | sed -e 's|^"||' -e 's|"$||'`
			# For some fun reason, the parameter ordering varies for
			# LUKS and non-LUKS devices.  Joy.
			if `$CS isLuks $csrc 2>/dev/null`; then
				echo "$cpass2" | $CS $copts luksOpen $csrc $cname >/dev/null
			else
				echo "$cpass2" | $CS $copts create $cname $csrc >/dev/null
			fi
		else
			if `$CS isLuks $csrc 2>/dev/null`; then
				$CS -d $cpass $copts luksOpen $csrc $cname >/dev/null
			else
				$CS -d $cpass $copts create $cname $csrc >/dev/null
			fi
		fi
	done </etc/crypttab
fi

if [ "$USELVM" = "yes" -o "$USELVM" = "YES" ]; then
	if [ -x /sbin/lvm -a -d /sys/block ]; then
		# Kernel 2.6.x, LVM2 groups
		stat_busy "Activating LVM2 groups"
		/sbin/lvm vgscan --ignorelockingfailure --mknodes
		/sbin/lvm vgchange --ignorelockingfailure -a y
		stat_done
	fi
fi

status "Mounting Root Read-only" /bin/mount -n -o remount,ro /

FORCEFSCK=
[ -f /forcefsck ] && FORCEFSCK="-- -f"
NETFS="nonfs,nosmbfs,nocifs,nocodafs,noncpfs,nosysfs,nousbfs,noshfs,nofuse"

if [ -x /sbin/fsck ]; then
	stat_busy "Checking Filesystems"
	if [ "`cat /proc/cmdline | grep quiet`" ]; then
		/sbin/fsck -A -T -C -a -t $NETFS $FORCEFSCK >/dev/null 2>&1
	else
		/sbin/fsck -A -T -C -a -t $NETFS $FORCEFSCK
	fi
	if [ $? -gt 1 ]; then
		stat_fail
		echo
		echo "*****************  FILESYSTEM CHECK FAILED  ****************"
		echo "*                                                          *"
		echo "*  Please repair manually and reboot. Note that the root   *"
		echo "*  file system is currently mounted read-only. To remount  *"
		echo "*  it read-write type: mount -n -o remount,rw /            *"
		echo "*  When you exit the maintenance shell the system will     *"
		echo "*  reboot automatically.                                   *"
		echo "*                                                          *"
		echo "************************************************************"
		echo
		/sbin/sulogin -p
		echo "Automatic reboot in progress..."
		/bin/umount -a
		/bin/mount -n -o remount,ro /
		/sbin/reboot -f
		exit 0
	fi
	stat_done
fi

stat_busy "Mounting Local Filesystems"
/bin/mount -n -o remount,rw /
/bin/rm -f /etc/mtab*
# make sure / gets written to /etc/mtab
/bin/mount -o remount,rw /
# re-mount /proc , /sys  and usbfs so they can be written to /etc/mtab
umount /proc/bus/usb
umount /proc && mount -t proc none /proc
[ "`grep sysfs /proc/filesystems`" ] && umount /sys && mount -t sysfs none /sys
[ "`grep usbfs /proc/filesystems`" ] && mount -t usbfs none /proc/bus/usb
# now mount all the local filesystems
/bin/mount -a -t $NETFS
stat_done

status "Activating Swap" /sbin/swapon -a

stat_busy "Configuring System Clock"
if [ "$HARDWARECLOCK" = "UTC" ]; then
	/sbin/hwclock --directisa --utc --hctosys
else
	/sbin/hwclock --directisa --localtime --hctosys
fi
if [ ! -f /var/lib/hwclock/adjtime ]; then
	echo "0.0 0 0.0" > /var/lib/hwclock/adjtime
fi
if [ "$TIMEZONE" != "" ]; then
	/bin/ln -sf /usr/share/zoneinfo/$TIMEZONE /etc/localtime
fi
stat_done

if [ -f /var/run/random-seed ]; then
	stat_busy "Initializing Random Seed"
	/bin/cat /var/run/random-seed >/dev/urandom
	stat_done
fi

stat_busy "Removing Leftover Files"
/bin/rm -f /etc/nologin &>/dev/null
/bin/rm -f /etc/shutdownpid &>/dev/null
/bin/rm -f /var/lock/* &>/dev/null
/bin/rm -rf /tmp/* /tmp/.* &>/dev/null
/bin/rm -f /forcefsck &>/dev/null
(cd /var/run && find . ! -type d -exec rm -f -- {} \; )
: > /var/run/utmp
# Keep {x,k,g}dm happy with xorg
mkdir /tmp/.ICE-unix && chmod 1777 /tmp/.ICE-unix
mkdir /tmp/.X11-unix && chmod 1777 /tmp/.X11-unix
stat_done

#status "Updating Shared Library Links" /sbin/ldconfig

if [ "$HOSTNAME" != "" ]; then
	status "Setting Hostname: $HOSTNAME" /bin/hostname $HOSTNAME
fi

# Set the NIS domain name, if necessary
[ -f /etc/conf.d/nisdomainname ] && . /etc/conf.d/nisdomainname
if [ "$NISDOMAINNAME" != "" ]; then
	status "Setting NIS Domain Name: $NISDOMAINNAME" /bin/nisdomainname $NISDOMAINNAME
fi

status "Updating Module Dependencies" /sbin/depmod -A

if [ "$KEYMAP" != "" ]; then
	status "Loading Keyboard Map: $KEYMAP" /bin/loadkeys -q $KEYMAP
fi

# Flush old locale settings
: >/etc/profile.d/locale.sh
chmod 755 /etc/profile.d/locale.sh
# Set user defined locale
if [ "$LOCALE" != "" ]; then
	stat_busy "Setting Locale: $LOCALE"
	echo "export LANG=$LOCALE" >>/etc/profile.d/locale.sh
	stat_done

#	If locale is *.utf set console to Unicode mode
	if [ "`echo $LOCALE | /bin/grep -i utf`" ]; then
		stat_busy "Setting Consoles to UTF-8"
		/usr/bin/kbd_mode -u
		/usr/bin/dumpkeys | /bin/loadkeys --unicode
		echo 'if [ "$TERM" = "linux" -a isatty ]; then echo -ne "\e%G"; fi' >>/etc/profile.d/locale.sh
		stat_done
	fi
fi
if [ "$CONSOLEFONT" != "" ]; then
	stat_busy "Loading Console Font: $CONSOLEFONT"
	for i in `seq 1 12`; do 
		if [ "$CONSOLEMAP" != "" ]; then
			/usr/bin/setfont -m $CONSOLEMAP $CONSOLEFONT -C /dev/vc/${i}
		else
			/usr/bin/setfont $CONSOLEFONT -C /dev/vc/${i}
		fi
	done
	echo 'if [ "$TERM" = "linux" -a isatty ]; then echo -ne "\e(K"; fi' >>/etc/profile.d/locale.sh
	stat_done
fi

# Screen blanks after 15 minutes idle time
/usr/bin/setterm -blank 15

# End of file
# vim: set ts=2 noet:
