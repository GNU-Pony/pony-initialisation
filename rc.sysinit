#!/bin/bash
#
# /etc/rc.sysinit
#

. /etc/rc.conf
. /etc/rc.d/functions

echo " "
printhl "Arch Linux\n"
printhl "${C_H2}http://www.archlinux.org"
printsep

run_hook sysinit_start

# export standard PATH (will be overridden later when /etc/profile is sourced, but is useful for UDev)
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# mount /proc, /sys, /run, /dev, /run/lock, /dev/pts, /dev/shm (the api filesystems)
mountpoint -q /proc    || mount -n -t proc proc /proc -o nosuid,noexec,nodev
mountpoint -q /sys     || mount -n -t sysfs sys /sys -o nosuid,noexec,nodev
mountpoint -q /run     || mount -n -t tmpfs run /run -o mode=755,size=10M,nosuid,nodev
if ! mountpoint -q /dev; then
	if grep -q devtmpfs /proc/filesystems &>/dev/null; then
		mount -n -t devtmpfs udev /dev -o mode=0755,size=10M,nosuid
	else
		mount -n -t tmpfs udev /dev -o mode=0755,size=10M,nosuid
	fi
fi
mkdir -p /run/lock /dev/{pts,shm}
chmod 1777 /run/lock
mountpoint -q /dev/pts || mount -n /dev/pts &> /dev/null \
	|| mount -n -t devpts devpts /dev/pts -o mode=620,gid=5,nosuid,noexec
mountpoint -q /dev/shm || mount -n /dev/shm &> /dev/null \
	|| mount -n -t tmpfs shm /dev/shm -o mode=1777,nosuid,nodev

# remount root ro to allow for fsck later on, we remount now to
# make sure nothing can open files rw on root which would block a remount
findmnt / --options ro &>/dev/null ||
	status "Mounting Root Read-Only" mount -n -o remount,ro /

# start up our mini logger until syslog takes over
minilogd
bootlogd -p /run/bootlogd.pid

HWCLOCK_PARAMS="--systz"
case $HARDWARECLOCK in
	"") ;;
	UTC) HWCLOCK_PARAMS+=" --utc --noadjfile";;
	localtime) HWCLOCK_PARAMS+=" --localtime --noadjfile";;
	*) HWCLOCK_PARAMS="";;
esac

if [[ $HWCLOCK_PARAMS ]]; then
	# enable rtc access
	modprobe -q -a rtc-cmos rtc genrtc
	# If devtmpfs is used, the required RTC device already exists now
	# Otherwise, create whatever device is available
	if ! [[ -c /dev/rtc || -c /dev/rtc0 ]]; then
		for dev in /sys/class/rtc/rtc0/dev /sys/class/misc/rtc/dev; do
			[[ -e $dev ]] || continue
			IFS=: read -r major minor < "$dev"
			mknod /dev/rtc c $major $minor
		done
	fi

	# Adjust the system time for timezone offset if rtc is not in UTC
	# 1. Make creation time on udev nodes sane (FS#8665)
	# 2. Filesystem checks can depend on system time
	# 3. This will set the clock, if using non-UTC, off the last known
	#    configured timezone. Any new timezone put in rc.conf is copied over at
	#    a later time.
	# This also sets the kernel time zone.
	if [[ -f /etc/localtime ]]; then
		hwclock $HWCLOCK_PARAMS
	fi
fi

status "Starting UDev Daemon" udevd --daemon

run_hook sysinit_udevlaunched

stat_busy "Triggering UDev uevents"
	udevadm trigger --action=add --type=subsystems
	udevadm trigger --action=add --type=devices
stat_done

# Load modules from the MODULES array defined in rc.conf
if [[ -f /proc/modules ]] && (( ${#MODULES[*]} )); then
	status "Loading Modules" modprobe -ab "${MODULES[@]}"
fi
unset mods

status "Waiting for UDev uevents to be processed" \
	udevadm settle --timeout=${UDEV_TIMEOUT:-30}

# in case loading a module changed the display mode
calc_columns

run_hook sysinit_udevsettled

# bring up the loopback interface
[[ -d /sys/class/net/lo ]] &&
	status "Bringing up loopback interface" ip link set up dev lo

# FakeRAID devices detection
if [[ $USEDMRAID = [Yy][Ee][Ss] && -x $(type -P dmraid) ]]; then
	status "Activating FakeRAID arrays" dmraid -i -ay
fi

# BTRFS devices detection
if [[ $USEBTRFS = [Yy][Ee][Ss] && -x $(type -P btrfs) ]]; then
	status "Activating BTRFS volumes" btrfs device scan
fi

activate_vgs

# Set up non-root encrypted partition mappings
if [[ -f /etc/crypttab && -n $CS ]] && grep -q ^[^#] /etc/crypttab; then
	modprobe -q dm-crypt 2>/dev/null
	stat_busy "Unlocking encrypted volumes:"
		do_unlock() {
			# $1 = requested name
			# $2 = source device
			# $3 = password
			# $4 = options
			stat_append "${1}.."
			local open=create a="$1" b="$2" failed=0
			# Ordering of options is different if you are using LUKS vs. not.
			# Use ugly swizzling to deal with it.
			# isLuks only gives an exit code but no output to stdout or stderr.
			if $CS isLuks "$2" 2>/dev/null; then
				open=luksOpen
				a="$2"
				b="$1"
			fi
			case $3 in
				SWAP)
					local _overwriteokay=0
					if [[ -b $2 && -r $2 ]]; then
						# This is DANGEROUS! If there is any known file system,
						# partition table, RAID or LVM volume on the device
						# we don't overwrite it.
						#
						# 'blkid' returns 2 if no valid signature has been found.
						# Only in this case we should allow overwriting the device.
						#
						# This sanity check _should_ be sufficient, but it might not.
						# This may cause dataloss if it is not used carefully.
						blkid -p "$2" &>/dev/null
						if [[ $? -eq 2 ]]; then
							_overwriteokay=1
						fi
					fi
					if [[ $_overwriteokay -eq 0 ]]; then
						false
					elif $CS -d /dev/urandom $4 $open "$a" "$b" >/dev/null; then
						stat_append "creating swapspace.."
						mkswap -f -L $1 /dev/mapper/$1 >/dev/null
					fi;;
				ASK)
					printf "\nOpening '$1' volume:\n"
					$CS $4 $open "$a" "$b" < /dev/console;;
				/dev*)
					ckdev=${3%%:*}
					cka=${3#*:}
					ckb=${cka#*:}
					cka=${cka%:*}
					ckfile=/dev/ckfile
					ckdir=/dev/ckdir
					case ${cka} in
						*[!0-9]*)
							# Use a file on the device
							# cka is not numeric: cka=filesystem, ckb=path
							mkdir ${ckdir}
							mount -r -t ${cka} ${ckdev} ${ckdir}
							dd if=${ckdir}/${ckb} of=${ckfile} >/dev/null 2>&1
							umount ${ckdir}
							rmdir ${ckdir};;
						*)
							# Read raw data from the block device
							# cka is numeric: cka=offset, ckb=length
							dd if=${ckdev} of=${ckfile} bs=1 skip=${cka} count=${ckb} >/dev/null 2>&1;;
					esac
					$CS -d ${ckfile} $4 $open "$a" "$b" >/dev/null
					dd if=/dev/urandom of=${ckfile} bs=1 count=$(stat -c %s ${ckfile}) conv=notrunc >/dev/null 2>&1
					rm ${ckfile};;
				/*)
					$CS -d "$3" $4 $open "$a" "$b" >/dev/null;;
				*)
					echo "$3" | $CS $4 $open "$a" "$b" >/dev/null;;
			esac
			if (($? != 0)); then
				failed=1
				stat_append "failed "
			else
				stat_append "ok "
			fi
			return $failed
		}
	crypto_unlocked=0
	if read_crypttab do_unlock; then
		stat_done
	else
		stat_fail
	fi
	if [[ ${crypto_unlocked} -eq 1 ]]; then
		# Maybe someone has LVM on an encrypted block device
		activate_vgs
	fi
fi

if [[ -x $(type -P fsck) ]]; then
	fsck_all
	fsck_reboot $?
fi

status "Remounting Root Read/Write" \
	mount -n -o remount,rw /

	# don't touch /etc/mtab if it is a symlink to /proc/self/mounts
	if [[ -L /etc/mtab ]]; then
		:
	elif [[ -x $(type -P findmnt) && -e /proc/self/mountinfo ]]; then
		findmnt -rnu -o SOURCE,TARGET,FSTYPE,OPTIONS >| /etc/mtab
	else
		cat /proc/mounts >| /etc/mtab
	fi

	# now mount all the local filesystems
mount_all

# enable monitoring of lvm2 groups, now that the filesystems are mounted rw
if [[ $USELVM = [Yy][Ee][Ss] && -x $(type -P lvm) && -d /sys/block ]]; then
	status "Activating monitoring of LVM2 groups" \
		vgchange --monitor y >/dev/null
fi

status "Activating Swap" swapon -a

if [[ $TIMEZONE ]]; then
	status "Configuring Time Zone" \
		cp --remove-destination "/usr/share/zoneinfo/$TIMEZONE" /etc/localtime
fi

RANDOM_SEED=/var/lib/misc/random-seed
if [[ -f $RANDOM_SEED ]]; then
	status "Initializing Random Seed" \
		cat $RANDOM_SEED > /dev/urandom
fi

stat_busy "Removing Leftover Files"
	rm -rf /etc/{nologin,shutdownpid} /forcefsck &>/dev/null
	rm -rf /tmp/* /tmp/.* &>/dev/null
	[[ ! -L /var/lock ]] && rm -rf /var/lock/*
	[[ ! -L /var/run && -d /var/run ]] && find /var/run/ \! -type d -delete
	[[ ! -L /var/run && ! -L /var/run/daemons ]] &&
		rm -rf /var/run/daemons &&
		ln -s /run/daemons /var/run/daemons
	install -Tm 0664 -o root -g utmp <(:) /var/run/utmp
	# Keep {x,k,g}dm happy with xorg
	mkdir -m1777 /tmp/.{X11,ICE}-unix
stat_done

if [[ $HOSTNAME ]]; then
	stat_busy "Setting Hostname: $HOSTNAME"
		echo $HOSTNAME > /proc/sys/kernel/hostname
	stat_done
fi

stat_busy "Setting Locale: ${LOCALE:=en_US}"
	# Flush old locale settings
	install -Tm 0755 <(:) /etc/profile.d/locale.sh
	# Set user defined locale
	echo "export LANG=$LOCALE" >>/etc/profile.d/locale.sh
stat_done

if [[ ${LOCALE,,} =~ utf ]]; then
	stat_busy "Setting Consoles to UTF-8 mode"
		# UTF-8 consoles are default since 2.6.24 kernel
		# this code is needed not only for older kernels,
		# but also when user has set vt.default_utf8=0 but LOCALE is *.UTF-8.
		for i in /dev/tty[0-9]*; do
			kbd_mode -u < ${i}
			printf "\e%%G" > ${i}
		done
		echo 1 > /sys/module/vt/parameters/default_utf8
	stat_done
	[[ $KEYMAP ]] && status "Loading Keyboard Map: $KEYMAP" loadkeys -q -u $KEYMAP
else
	stat_busy "Setting Consoles to legacy mode"
		# make non-UTF-8 consoles work on 2.6.24 and newer kernels
		for i in /dev/tty[0-9]*; do
			kbd_mode -a < ${i}
			printf "\e%%@" > ${i}
		done
		echo 0 > /sys/module/vt/parameters/default_utf8
	stat_done
	[[ $KEYMAP ]] && status "Loading Keyboard Map: $KEYMAP" loadkeys -q $KEYMAP
fi

# Set console font if required
set_consolefont

if [[ -e /proc/sys/kernel/dmesg_restrict && $(< /proc/sys/kernel/dmesg_restrict) -eq 1 ]]; then
    install -Tm 0600 <( dmesg ) /var/log/dmesg.log
else
    install -Tm 0644 <( dmesg ) /var/log/dmesg.log
fi

run_hook sysinit_end

# End of file
# vim: set ts=2 sw=2 noet:
