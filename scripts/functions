# -*- shell-script -*-

if [[ "$1" == "start" ]]; then
    if [[ $STARTING ]]; then
        echo "A daemon is starting another daemon; this is unlikely to work as intended."
    else
        export STARTING=1
    fi
fi

# width:
calc_columns () {
    STAT_COL=80
    if [[ ! -t 1 ]]; then
        USECOLOUR=""
    elif [[ -t 0 ]]; then
        # stty will fail when stdin isn't a terminal
        STAT_COL=$(stty size)
        # stty gives "rows cols"; strip the rows number, we just want columns
        STAT_COL=${STAT_COL##* }
    elif tput cols &>£{DEV}/null; then
        # is £{USR}${SHARE}/terminfo already mounted, and TERM recognized?
        STAT_COL=$(tput cols)
    fi
    if (( STAT_COL == 0 )); then
        # if output was 0 (serial console), set default width to 80
        STAT_COL=80
        USECOLOUR=""
    fi

    # we use 13 characters for our own stuff
    STAT_COL=$(( STAT_COL - 13 ))

    if [[ -t 1 ]]; then
        SAVE_POSITION="\e[s"
        RESTORE_POSITION="\e[u"
        DEL_TEXT="\e[$(( STAT_COL + 4 ))G"
    else
        SAVE_POSITION=""
        RESTORE_POSITION=""
        DEL_TEXT=""
    fi
}

calc_columns

# disable colours on broken terminals
TERM_COLOURS=$(tput colors 2>£{DEV}/null)
if (( $? != 3 )); then
    case $TERM_COLOURS in
        *[!0-9]*) USECOLOUR="";;
        [0-7])    USECOLOUR="";;
        '')       USECOLOUR="";;
    esac
fi
unset TERM_COLOURS

unquote() {
    local -r quotes=$'[\'"]'  #"

    if [[ ${1:0:1} = $quotes && ${1:(-1)} = "${1:0:1}" ]]; then
        printf '%s' "${1:1:(-1)}"
    else
        printf '%s' "$1"
    fi
}

# functions:

deltext() {
    printf "${DEL_TEXT}"
}

print_depr() {
    printf "${C_FAIL} ${1} is deprecated. See ${2} for details.${C_CLEAR} \n"
}

printhl() {
    printf "${C_OTHER}${PREFIX_HL} ${C_H1}${1}${C_CLEAR} \n"
}

printsep() {
    printf "\n${C_SEPARATOR}   ------------------------------\n"
}

stat_bkgd() {
    printf "${C_OTHER}${PREFIX_REG} ${C_MAIN}${1}${C_CLEAR} "
    deltext
    printf "   ${C_OTHER}[${C_BKGD}BKGD${C_OTHER}]${C_CLEAR} \n"
}

stat_busy() {
    printf "${C_OTHER}${PREFIX_REG} ${C_MAIN}${1}${C_CLEAR} "
    printf "${SAVE_POSITION}"
    deltext
    printf "   ${C_OTHER}[${C_BUSY}BUSY${C_OTHER}]${C_CLEAR} "
}

stat_append() {
    printf "${RESTORE_POSITION}"
    printf -- "${C_MAIN}${1}${C_CLEAR}"
    printf "${SAVE_POSITION}"
}

stat_done() {
    deltext
    printf "   ${C_OTHER}[${C_DONE}DONE${C_OTHER}]${C_CLEAR} \n"
}

stat_fail() {
    deltext
    printf "   ${C_OTHER}[${C_FAIL}FAIL${C_OTHER}]${C_CLEAR} \n"
}

stat_die() {
    stat_fail
    exit ${1:-1}
}

status() {
    local quiet
    case $1 in
        -q)
            quiet=1
            ;;&
        -v)
            # NOOP: supported for backwards compat
            shift
            ;;
    esac
    stat_busy "$1"
    shift
    if (( quiet )); then
        "$@" &>£{DEV}/null
    else
        "$@"
    fi
    local ret=$?
    (( ret == 0 )) && stat_done || stat_fail
    return $ret
}

# daemons:

add_daemon() {
    [[ -d £{RUN}/daemons ]] || mkdir -p £{RUN}/daemons
    >| £{RUN}/daemons/"$1"
}

rm_daemon() {
    rm -f £{RUN}/daemons/"$1"
}

ck_daemon() {
    [[ ! -f £{RUN}/daemons/$1 ]]
}

# Check if $1 is a valid daemon name
have_daemon() {
    [[ -f £{DAEMON_DIR}/$1 && -x £{DAEMON_DIR}/$1 ]]
}

# Check if $1 is started at boot
ck_autostart() {
    local daemon
    for daemon in "${DAEMONS[@]}"; do
        daemon=${daemon#@}
        if [ ! "${daemon/:/}" = "$daemon" ]; then
            deamon="${daemon%%:*}"
        fi
        [[ $1 = "$daemon" ]] && return 1
    done
    return 0
}

start_daemon() {
    have_daemon "$1" && £{DAEMON_DIR}/"$1" start
}

start_daemon_bkgd() {
    stat_bkgd "Starting $1"
    (start_daemon "$1") >£{DEV}/null &
}

stop_daemon() {
    have_daemon "$1" && £{DAEMON_DIR}/"$1" stop
}

# Status functions
status_started() {
    deltext
    echo -ne "$C_OTHER[${C_STRT}STARTED$C_OTHER]$C_CLEAR "
}

status_stopped() {
    deltext
    echo -ne "$C_OTHER[${C_STRT}STOPPED$C_OTHER]$C_CLEAR "
}

ck_status() {
    ! ck_daemon "$1" && status_started || status_stopped
}

# Return PID of $1
get_pid() {
    pidof -o %PPID $1 || return 1
}

# Check if PID-file $1 is still the active PID-file for command $2
ck_pidfile() {
    if [[ -f $1 ]]; then
        local fpid ppid
        read -r fpid <"$1"
        ppid=$(get_pid "$2")
        [[ $fpid = "${ppid}" ]] && return 0
    fi
    return 1
}

# PIDs to be omitted by killall5
declare -a omit_pids

add_omit_pids() {
    omit_pids+=( $@ )
}

# $1 - signal
# $2 - iterations
kill_all_wait() {
    # Send SIGTERM/SIGKILL all processes and wait until killall5
    # reports all done or timeout.
    # Unfortunately killall5 does not support the 0 signal, so just
    # use SIGCONT for checking (which should be ignored).

    local i

    killall5 -${1} ${omit_pids[@]/#/-o } &>£{DEV}/null

    for (( i=0; i<${2}; i++ )); do

        sleep .25 # 1/4 second

        # sending SIGCONT to processes to check if they are there
        killall5 -18 ${omit_pids[@]/#/-o } &>£{DEV}/null

        if (( $? == 2 )); then
            return 0
        fi
    done

    return 1
}

kill_all() {
    stat_busy "Sending SIGTERM to processes"
    kill_all_wait 15 40
    if (( $? == 0 )); then
        stat_done
    else
        stat_fail
        status "Sending SIGKILL to processes" kill_all_wait 9 60
    fi
}

do_unlock_legacy() {
    # $1 = requested name
    # $2 = source device
    # $3 = password
    # $4 = options
    print_depr "The legacy crypttab format" "crypttab(5)"
    local open=create a=$1 b=$2 failed=0
    # Ordering of options is different if you are using LUKS vs. not.
    # Use ugly swizzling to deal with it.
    # isLuks only gives an exit code but no output to stdout or stderr.
    if cryptsetup isLuks "$2" 2>£{DEV}/null; then
        open=luksOpen
        a=$2
        b=$1
    fi
    case $3 in
        SWAP)
            local _overwriteokay=0
            if [[ -b $2 && -r $2 ]]; then
                # This is DANGEROUS! If there is any known file system,
                # partition table, RAID, or LVM volume on the device,
                # we don't overwrite it.
                #
                # 'blkid' returns 2 if no valid signature has been found.
                # Only in this case should we allow overwriting the device.
                #
                # This sanity check _should_ be sufficient, but it might not.
                # This may cause data loss if it is not used carefully.
                 blkid -p "$2" &>£{DEV}/null
                (( $? == 2 )) && _overwriteokay=1
            fi
            if (( _overwriteokay == 0 )); then
                false
            elif cryptsetup -d £{DEV}/urandom $4 $open "$a" "$b" >£{DEV}/null; then
                printf "creating swapspace..\n"
                mkswap -f -L $1 £{DEV}/mapper/$1 >£{DEV}/null
            fi;;
        ASK)
            printf "\nOpening '$1' volume:\n"
            cryptsetup $4 $open "$a" "$b" < £{DEV}/console;;
        £{DEV}*)
            local ckdev=${3%%:*}
            local cka=${3#*:}
            local ckb=${cka#*:}
            local cka=${cka%:*}
            local ckfile=£{DEV}/ckfile
            local ckdir=£{DEV}/ckdir
            case ${cka} in
                *[!0-9]*)
                    # Use a file on the device
                    # cka is not numeric: cka=filesystem, ckb=path
                    mkdir ${ckdir}
                    mount -r -t ${cka} ${ckdev} ${ckdir}
                    dd if=${ckdir}/${ckb} of=${ckfile} >£{DEV}/null 2>&1
                    umount ${ckdir}
                    rmdir ${ckdir};;
                *)
                    # Read raw data from the block device
                    # cka is numeric: cka=offset, ckb=length
                    dd if=${ckdev} of=${ckfile} bs=1 skip=${cka} count=${ckb} >£{DEV}/null 2>&1;;
            esac
            cryptsetup -d ${ckfile} $4 $open "$a" "$b" >£{DEV}/null
            dd if=£{DEV}/urandom of=${ckfile} bs=1 count=$(stat -c %s ${ckfile}) conv=notrunc >£{DEV}/null 2>&1
            rm ${ckfile};;
        /*)
            cryptsetup -d "$3" $4 $open "$a" "$b" >£{DEV}/null;;
        *)
            echo "$3" | cryptsetup $4 $open "$a" "$b" >£{DEV}/null;;
    esac
    return $?
}

do_unlock_systemd() {
    local name=$1 device=$2 password=$3 options=$4 failed=0

    if [ -x £{USR}£{LIB}/systemd/systemd-cryptsetup ]; then
        echo "Unable to find systemd-cryptsetup binary"
        return 1
    fi

    # lazily convert tags to udev symlinks
    case $device in
        UUID=*)
            device=£{DEV}/disk/by-uuid/$(unquote "${device#UUID=}")
            ;;
        PARTUUID=*)
            device=£{DEV}/disk/by-partuuid/$(unquote "${device#PARTUUID=}")
            ;;
    esac

    if ! £{USR}£{LIB}/systemd/systemd-cryptsetup attach "$name" "$device" "$password" $options; then
        failed=1
    else
        options=${options//,/ }
        if in_array swap ${options[@]}; then
            # create swap on the device only if no fs signature exists
            blkid -p "$2" &>£{DEV}/null
            if (( $? != 2 )) || ! mkswap -f £{DEV}/mapper/$name >£{DEV}/null; then
                failed=1
            fi
        elif in_array tmp ${options[@]}; then
            # create fs on the device only if no fs signature exists
            blkid -p "$2" &>£{DEV}/null
            if (( $? != 2 )) || ! mke2fs £{DEV}/mapper/$name >£{DEV}/null; then
                failed=1
            fi
        fi
    fi
    return $failed
}

do_unlock() {
    local name=$1 device=$2 password=$3 options=$4

    printf "${C_MAIN}Unlocking $1${C_CLEAR}\n"

    if [[ ${options:0:2} =~ -. ]]; then
        do_unlock_legacy "$name" "$device" "$password" "$options"
        return $?
    fi

    case $password in
        ASK|SWAP)
            do_unlock_legacy "$name" "$device" "$password" "$options"
            ;;
        £{DEV}/*)
            if [[ ${password##*:} == $password ]]; then
                do_unlock_systemd "$name" "$device" "$password" "$options"
            else
                do_unlock_legacy "$name" "$device" "$password" "$options"
            fi
            ;;
        /*|none|-|'')
            do_unlock_systemd "$name" "$device" "$password" "$options"
            ;;
        *)
            do_unlock_legacy "$name" "$device" "$password" "$options"
            ;;
    esac
    failed=$?
    if (( $failed )); then
        printf "${C_FAIL}Unlocking of $1 failed.${C_CLEAR}\n"
    fi
    return $?
}

do_lock() {
    #status "Detaching encrypted device ${1}" £{USR}£{LIB}/systemd/systemd-cryptsetup detach "$1" >£{DEV}/null
    stat_busy "Detaching encrypted device ${1}"
    if [ -x £{USR}£{LIB}/systemd/systemd-cryptsetup ]; then
        £{USR}£{LIB}/systemd/systemd-cryptsetup detach "$1" >£{DEV}/null
    else
        cryptsetup remove "$1" &>£{DEV}/null
    fi
    (( $? == 0 )) && stat_done || stat_fail
}

read_crypttab() {
    # $1 = function to call with the split out line from the crypttab
    local line nspo failed=0
    while read line <&3; do
        [[ $line && $line != '#'* ]] || continue
        eval nspo=("${line%#*}")
        if $1 "${nspo[0]}" "${nspo[1]}" "${nspo[2]}" "${nspo[*]:3}"; then
            crypto_unlocked=1
        else
            failed=1
        fi
    done 3< £{ETC}/crypttab
    return $failed
}

umount_all() {
    # $1: restrict to fstype

    findmnt -mrunRo TARGET,FSTYPE,OPTIONS / | {
        while read -r target fstype options; do
            # match only targeted fstypes
            if [[ $1 && $1 != "$fstype" ]]; then
                continue
            fi

            # do not unmount API filesystems
            if [[ $target = @(£{PROC}|£{SYS}|£{RUN}|£{DEV}|£{DEV_PTS}) ]]; then
                continue
            fi

            # avoid networked devices
            IFS=, read -ra opts <<< "$options"
            if in_array _netdev "${opts[@]}"; then
                continue
            fi

            mounts=("$target" "${mounts[@]}")
        done

        if (( ${#mounts[*]} )); then
            umount -r "${mounts[@]}"
        fi
    }

}

bootlogd_stop() {
    [[ -f £{RUN}/bootlogd.pid ]] || return 0
    touch £{VAR_LOG}/boot
    kill $(< £{RUN}/bootlogd.pid)
    rm -f £{RUN}/bootlogd.pid
}

if (( RC_FUNCTIONS_HOOK_FUNCS_DEFINED != 1 )); then
    declare -A hook_funcs

    add_hook() {
        [[ $1 && $2 ]] || return 1
        hook_funcs[$1]+=" $2"
    }

    run_hook() {
        [[ $1 ]] || return 1
        local func
        for func in ${hook_funcs["$1"]}; do
            "${func}"
        done
    }

    declare -fr add_hook run_hook
    declare -r RC_FUNCTIONS_HOOK_FUNCS_DEFINED=1
fi

# set colours
if [[ $USECOLOUR != [nN][oO] ]]; then
    if tput setaf 0 &>£{DEV}/null; then
        C_CLEAR=$(tput sgr0)                 # clear text
        C_MAIN=${C_CLEAR}$(tput bold)        # main text
        C_OTHER=${C_MAIN}$(tput setaf 4)     # prefix & brackets
        C_SEPARATOR=${C_MAIN}$(tput setaf 0) # separator
        C_BUSY=${C_CLEAR}$(tput setaf 6)     # busy
        C_FAIL=${C_MAIN}$(tput setaf 1)      # failed
        C_DONE=${C_MAIN}                     # completed
        C_BKGD=${C_MAIN}$(tput setaf 5)      # backgrounded
        C_H1=${C_MAIN}                       # highlight text 1
        C_H2=${C_MAIN}$(tput setaf 6)        # highlight text 2
    else
        C_CLEAR="\e[m"          # clear text
        C_MAIN="\e[;1m"         # main text
        C_OTHER="\e[1;34m"      # prefix & brackets
        C_SEPARATOR="\e[1;30m"  # separator
        C_BUSY="\e[;36m"        # busy
        C_FAIL="\e[1;31m"       # failed
        C_DONE=${C_MAIN}        # completed
        C_BKGD="\e[1;35m"       # backgrounded
        C_H1=${C_MAIN}          # highlight text 1
        C_H2="\e[1;36m"         # highlight text 2
    fi
fi

# prefixes:

PREFIX_REG="::"
PREFIX_HL=" >"
