# -*- shell-script -*-

if [[ "$1" == "start" ]]; then
    if [[ $STARTING ]]; then
        echo "A daemon is starting another daemon; this is unlikely to work as intended."
    else
        export STARTING=1
    fi
fi

# width:
calc_columns () {
    STAT_COL=80
    if [[ ! -t 1 ]]; then
        USECOLOUR=""
    elif [[ -t 0 ]]; then
        # stty will fail when stdin isn't a terminal
        STAT_COL=$(stty size)
        # stty gives "rows cols"; strip the rows number, we just want columns
        STAT_COL=${STAT_COL##* }
    elif tput cols &>£{DEV}/null; then
        # is £{USR}${SHARE}/terminfo already mounted, and TERM recognized?
        STAT_COL=$(tput cols)
    fi
    if (( STAT_COL == 0 )); then
        # if output was 0 (serial console), set default width to 80
        STAT_COL=80
        USECOLOUR=""
    fi

    # we use 13 characters for our own stuff
    STAT_COL=$(( STAT_COL - 13 ))

    if [[ -t 1 ]]; then
        SAVE_POSITION="\e[s"
        RESTORE_POSITION="\e[u"
        DEL_TEXT="\e[$(( STAT_COL + 4 ))G"
    else
        SAVE_POSITION=""
        RESTORE_POSITION=""
        DEL_TEXT=""
    fi
}

calc_columns

# disable colours on broken terminals
TERM_COLOURS=$(tput colors 2>£{DEV}/null)
if (( $? != 3 )); then
    case $TERM_COLOURS in
        *[!0-9]*) USECOLOUR="";;
        [0-7])    USECOLOUR="";;
        '')       USECOLOUR="";;
    esac
fi
unset TERM_COLOURS

unquote() {
    local -r quotes=$'[\'"]'  #"

    if [[ ${1:0:1} = $quotes && ${1:(-1)} = "${1:0:1}" ]]; then
        printf '%s' "${1:1:(-1)}"
    else
        printf '%s' "$1"
    fi
}

# functions:

deltext() {
    printf "${DEL_TEXT}"
}

print_depr() {
    printf "${C_FAIL} ${1} is deprecated. See ${2} for details.${C_CLEAR} \n"
}

printhl() {
    printf "${C_OTHER}${PREFIX_HL} ${C_H1}${1}${C_CLEAR} \n"
}

printsep() {
    printf "\n${C_SEPARATOR}   ------------------------------\n"
}

stat_bkgd() {
    printf "${C_OTHER}${PREFIX_REG} ${C_MAIN}${1}${C_CLEAR} "
    deltext
    printf "   ${C_OTHER}[${C_BKGD}BKGD${C_OTHER}]${C_CLEAR} \n"
}

stat_busy() {
    printf "${C_OTHER}${PREFIX_REG} ${C_MAIN}${1}${C_CLEAR} "
    printf "${SAVE_POSITION}"
    deltext
    printf "   ${C_OTHER}[${C_BUSY}BUSY${C_OTHER}]${C_CLEAR} "
}

stat_append() {
    printf "${RESTORE_POSITION}"
    printf -- "${C_MAIN}${1}${C_CLEAR}"
    printf "${SAVE_POSITION}"
}

stat_done() {
    deltext
    printf "   ${C_OTHER}[${C_DONE}DONE${C_OTHER}]${C_CLEAR} \n"
}

stat_fail() {
    deltext
    printf "   ${C_OTHER}[${C_FAIL}FAIL${C_OTHER}]${C_CLEAR} \n"
}

stat_die() {
    stat_fail
    exit ${1:-1}
}

status() {
    local quiet
    case $1 in
        -q)
            quiet=1
            ;;&
        -v)
            # NOOP: supported for backwards compat
            shift
            ;;
    esac
    stat_busy "$1"
    shift
    if (( quiet )); then
        "$@" &>£{DEV}/null
    else
        "$@"
    fi
    local ret=$?
    (( ret == 0 )) && stat_done || stat_fail
    return $ret
}

# Status functions
status_started() {
    deltext
    echo -ne "$C_OTHER[${C_STRT}STARTED$C_OTHER]$C_CLEAR "
}

status_stopped() {
    deltext
    echo -ne "$C_OTHER[${C_STRT}STOPPED$C_OTHER]$C_CLEAR "
}

ck_status() {
    ! ck_daemon "$1" && status_started || status_stopped
}

# Return PID of $1
get_pid() {
    pidof -o %PPID $1 || return 1
}

# Check if PID-file $1 is still the active PID-file for command $2
ck_pidfile() {
    if [[ -f $1 ]]; then
        local fpid ppid
        read -r fpid <"$1"
        ppid=$(get_pid "$2")
        [[ $fpid = "${ppid}" ]] && return 0
    fi
    return 1
}

# PIDs to be omitted by killall5
declare -a omit_pids

add_omit_pids() {
    omit_pids+=( $@ )
}

# $1 - signal
# $2 - iterations
kill_all_wait() {
    # Send SIGTERM/SIGKILL all processes and wait until killall5
    # reports all done or timeout.
    # Unfortunately killall5 does not support the 0 signal, so just
    # use SIGCONT for checking (which should be ignored).

    local i

    killall5 -${1} ${omit_pids[@]/#/-o } &>£{DEV}/null

    for (( i=0; i<${2}; i++ )); do

        sleep .25 # 1/4 second

        # sending SIGCONT to processes to check if they are there
        killall5 -18 ${omit_pids[@]/#/-o } &>£{DEV}/null

        if (( $? == 2 )); then
            return 0
        fi
    done

    return 1
}

kill_all() {
    stat_busy "Sending SIGTERM to processes"
    kill_all_wait 15 40
    if (( $? == 0 )); then
        stat_done
    else
        stat_fail
        status "Sending SIGKILL to processes" kill_all_wait 9 60
    fi
}

do_unlock_systemd() {
    local name=$1 device=$2 password=$3 options=$4 failed=0

    if [ -x £{USR}£{LIB}/systemd/systemd-cryptsetup ]; then
        echo "Unable to find systemd-cryptsetup binary"
        return 1
    fi

    # lazily convert tags to udev symlinks
    case $device in
        UUID=*)
            device=£{DEV}/disk/by-uuid/$(unquote "${device#UUID=}")
            ;;
        PARTUUID=*)
            device=£{DEV}/disk/by-partuuid/$(unquote "${device#PARTUUID=}")
            ;;
    esac

    if ! £{USR}£{LIB}/systemd/systemd-cryptsetup attach "$name" "$device" "$password" $options; then
        failed=1
    else
        options=${options//,/ }
        if in_array swap ${options[@]}; then
            # create swap on the device only if no fs signature exists
            blkid -p "$2" &>£{DEV}/null
            if (( $? != 2 )) || ! mkswap -f £{DEV}/mapper/$name >£{DEV}/null; then
                failed=1
            fi
        elif in_array tmp ${options[@]}; then
            # create fs on the device only if no fs signature exists
            blkid -p "$2" &>£{DEV}/null
            if (( $? != 2 )) || ! mke2fs £{DEV}/mapper/$name >£{DEV}/null; then
                failed=1
            fi
        fi
    fi
    return $failed
}

do_unlock() {
    local name=$1 device=$2 password=$3 options=$4

    printf "${C_MAIN}Unlocking $1${C_CLEAR}\n"

    if [[ ${options:0:2} =~ -. ]]; then
        do_unlock_legacy "$name" "$device" "$password" "$options"
        return $?
    fi

    case $password in
        ASK|SWAP)
            do_unlock_legacy "$name" "$device" "$password" "$options"
            ;;
        £{DEV}/*)
            if [[ ${password##*:} == $password ]]; then
                do_unlock_systemd "$name" "$device" "$password" "$options"
            else
                do_unlock_legacy "$name" "$device" "$password" "$options"
            fi
            ;;
        /*|none|-|'')
            do_unlock_systemd "$name" "$device" "$password" "$options"
            ;;
        *)
            do_unlock_legacy "$name" "$device" "$password" "$options"
            ;;
    esac
    failed=$?
    if (( $failed )); then
        printf "${C_FAIL}Unlocking of $1 failed.${C_CLEAR}\n"
    fi
    return $?
}

do_lock() {
    #status "Detaching encrypted device ${1}" £{USR}£{LIB}/systemd/systemd-cryptsetup detach "$1" >£{DEV}/null
    stat_busy "Detaching encrypted device ${1}"
    if [ -x £{USR}£{LIB}/systemd/systemd-cryptsetup ]; then
        £{USR}£{LIB}/systemd/systemd-cryptsetup detach "$1" >£{DEV}/null
    else
        cryptsetup remove "$1" &>£{DEV}/null
    fi
    (( $? == 0 )) && stat_done || stat_fail
}

umount_all() {
    # $1: restrict to fstype

    findmnt -mrunRo TARGET,FSTYPE,OPTIONS / | {
        while read -r target fstype options; do
            # match only targeted fstypes
            if [[ $1 && $1 != "$fstype" ]]; then
                continue
            fi

            # do not unmount API filesystems
            if [[ $target = @(£{PROC}|£{SYS}|£{RUN}|£{DEV}|£{DEV_PTS}) ]]; then
                continue
            fi

            # avoid networked devices
            IFS=, read -ra opts <<< "$options"
            if in_array _netdev "${opts[@]}"; then
                continue
            fi

            mounts=("$target" "${mounts[@]}")
        done

        if (( ${#mounts[*]} )); then
            umount -r "${mounts[@]}"
        fi
    }

}

bootlogd_stop() {
    [[ -f £{RUN}/bootlogd.pid ]] || return 0
    touch £{VAR_LOG}/boot
    kill $(< £{RUN}/bootlogd.pid)
    rm -f £{RUN}/bootlogd.pid
}

if (( RC_FUNCTIONS_HOOK_FUNCS_DEFINED != 1 )); then
    declare -A hook_funcs

    add_hook() {
        [[ $1 && $2 ]] || return 1
        hook_funcs[$1]+=" $2"
    }

    run_hook() {
        [[ $1 ]] || return 1
        local func
        for func in ${hook_funcs["$1"]}; do
            "${func}"
        done
    }

    declare -fr add_hook run_hook
    declare -r RC_FUNCTIONS_HOOK_FUNCS_DEFINED=1
fi

# set colours
if [[ $USECOLOUR != [nN][oO] ]]; then
    if tput setaf 0 &>£{DEV}/null; then
        C_CLEAR=$(tput sgr0)                 # clear text
        C_MAIN=${C_CLEAR}$(tput bold)        # main text
        C_OTHER=${C_MAIN}$(tput setaf 4)     # prefix & brackets
        C_SEPARATOR=${C_MAIN}$(tput setaf 0) # separator
        C_BUSY=${C_CLEAR}$(tput setaf 6)     # busy
        C_FAIL=${C_MAIN}$(tput setaf 1)      # failed
        C_DONE=${C_MAIN}                     # completed
        C_BKGD=${C_MAIN}$(tput setaf 5)      # backgrounded
        C_H1=${C_MAIN}                       # highlight text 1
        C_H2=${C_MAIN}$(tput setaf 6)        # highlight text 2
    else
        C_CLEAR="\e[m"          # clear text
        C_MAIN="\e[;1m"         # main text
        C_OTHER="\e[1;34m"      # prefix & brackets
        C_SEPARATOR="\e[1;30m"  # separator
        C_BUSY="\e[;36m"        # busy
        C_FAIL="\e[1;31m"       # failed
        C_DONE=${C_MAIN}        # completed
        C_BKGD="\e[1;35m"       # backgrounded
        C_H1=${C_MAIN}          # highlight text 1
        C_H2="\e[1;36m"         # highlight text 2
    fi
fi

# prefixes:

PREFIX_REG="::"
PREFIX_HL=" >"
