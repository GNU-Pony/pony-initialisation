#!/usr/bin/python3
# -*- mode: python, coding: utf-8 -*-
#
# Single-user start-up script
#

_msg = None
_singular = lambda text = None : print(      '\033[01;35m%s\033[00;30m [SNGL]\033[00m'   % (_msg if text is None else text))
_working  = lambda text = None : print(      '\033[01;33m%s\033[00;30m [WORK]\033[00m'   % (_msg if text is None else text))
_done     = lambda text = None : print('\033[A\033[01;32m%s\033[00;30m [DONE]\033[00m'   % (_msg if text is None else text))
_failure  = lambda text = None : print(      '\033[01;32m%s\033[00;30m [FAIL]\033[00m'   % (_msg if text is None else text))


### Load libraries

_msg = 'Load libraries'
_working()

import os
import time
import signal
from subprocess import Popen, PIPE


def _(*args):
    '''
    Spawn a subprocess an wait for it to exit
    
    @param   args  The command line arguments
    @return        Whether the process was successful
    '''
    try:
        proc = Popen(list(args))
        proc.wait()
        return proc.returncode == 0
    except:
        return False


def __(*args):
    '''
    Spawn a subprocess, but suppress stdout and stderr
    
    @param   args  The command line arguments
    @return        The process
    '''
    return Popen(list(args), stdout = PIPE, stderr = PIPE)

_done()


### Prepare to exit current runlevel
if not os.getenv("PREVLEVEL", "") == "N":
    ### Stop all daemons
    _msg = 'Stop all daemons'
    _working()
    (_("daemond", "stop-all") and _done()) or _failure()
    
    
    ### Try to terminate all process, then kill them
    _msg = 'Terminate all process'
    _working()
    try:
        def kill_all_wait(sig, iterations):
            try:
                __("killall5", "-" + str(sig)).wait()
            except:
                return False
            for _ in range(iterations):
                time.sleep(0.25)
                proc = _("killall5", "-" + str(signal.SIGCONT))
                proc.wait()
                if proc.returncode == 2:
                    return True
            return False
        (kill_all_wait(signal.SIGTERM, 40) or kill_all_wait(signal.SIGKILL, 60) or _failure()) and _done()
    except:
        _failure()
    
    
    ### Start/trigger udev, load MODULES, and settle udev
    _msg = 'Disable blacklisted kernel modules'
    _working()
    try:
        if not isinstance(MODULES, str):
            blacklist = list(filter(lambda module : module.startswith("!"), MODULES))
            if len(blacklist) > 0:
                blacklist = [blacklist[1:] for excl_module in blacklist]
                os.makedirs("£{RUN}/modprobe.d", exist_ok = True)
                with open("£{RUN}/modprobe.d/modprobe-blacklist.conf", "w") as file:
                    file.write("# Autogenerated from rc.conf at boot, do not edit\n")
                    file.write("blacklist %s\n" % " ".join(blacklist))
                    file.flush()
        _done()
    except:
        _failure()
    
    _msg = 'Start and trigger devd'
    _working()
    devd_command = 'devd' if in_path('devd') else 'udevd'
    devadm_command = 'devadm' if in_path('devadm') else 'udevadm'
    # You should really have symlinks named devd and devadm to your device daemon and controller
    try:
        (_(devd_command, "--daemon") and
         _(devadm_command, "trigger", "--action=add", "--type=subsystems") and
         _(devadm_command, "trigger", "--action=add", "--type=devices") and
         _done()) or _failure()
    except:
        _failure()
    
    _msg = 'Load kernel modules'
    _working()
    try:
        whitelisted_modules = list(filter(lambda module : not module.startswith("!"), MODULES))
        if len(whitelisted_modules) > 0:
            (_("modprobe", "-ab", *whitelisted_modules) and _done()) or _failure()
        else:
            _done()
    except:
        _failuer()
    
    _msg = 'Settle devd'
    _working()
    (_(devadm_command, "settle") and _done()) or _failure()


### Stop boot logging
_msg = 'Stop boot logging'
_working()
try:
    if os.path.exists("£{RUN}/bootlogd.pid"):
        with open("£{VAR_LOG}/boot", "a") as file:
            file.flush()
        with open("£{RUN}/bootlogd.pid", "r") as file:
            os.kill(int(file.read().replace("\n", "")), signal.SIGTERM)
        os.remove("£{RUN}/bootlogd.pid")
    _done()
except:
    _failure()


### Switch runlevel
if os.getenv("RUNLEVEL", "") == "1":
    _singular('Switch runlevel')
    os.kill(1, signal.SIGHUP)
    os.execl("£{SBIN}/init", "init", "-t1", "S")

